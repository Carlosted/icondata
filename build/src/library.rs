use anyhow::Result;
use std::path::{Path, PathBuf};
use tokio::io::AsyncWriteExt;
use tracing::{error, info, instrument};

use crate::{feature::Feature, path};

const BASE_CARGO_TOML: &'static str = indoc::indoc!(
    r#"
    # ------------------------------------------------------------------------------------------
    # THIS FILE WAS GENERATED BY THE "BUILD" CRATE.
    # ONLY MAKE MODIFICATIONS IN build/src/generate.rs! SEE `const BASE_CARGO_TOML`.
    # ------------------------------------------------------------------------------------------

    [package]
    name = "leptos-icons"
    version = "0.1.0"
    edition = "2021"

    [dependencies]
    leptos = { version = "0.2", default-features = false }
    tracing = { version = "0.1", optional = true }

    [features]
    tracing = ["dep:tracing"]

"#
);

#[derive(Debug)]
pub(crate) struct Library {
    path: PathBuf,
    cargo_toml: CargoToml,
    src_dir: SrcDir,
}

impl Library {
    pub fn new() -> Self {
        Self {
            path: path::leptos_icons_crate(""),
            cargo_toml: CargoToml {
                file_path: path::leptos_icons_crate("Cargo.toml"),
            },
            src_dir: SrcDir {
                path: path::leptos_icons_crate("src"),
                lib_rs: LibRs {
                    path: path::leptos_icons_crate("src").join("lib.rs"),
                },
            },
        }
    }

    pub fn cargo_toml(&self) -> &CargoToml {
        &self.cargo_toml
    }

    pub fn src_dir(&self) -> &SrcDir {
        &self.src_dir
    }

    #[allow(unused)]
    pub fn relative_path<P: AsRef<Path>>(&self, join: P) -> PathBuf {
        self.path.join(join)
    }
}

#[derive(Debug)]
pub(crate) struct SrcDir {
    path: PathBuf,
    lib_rs: LibRs,
}

impl SrcDir {
    /// Removes everything inside and creates a fresh lib.rs file.
    pub async fn reset(&self) -> Result<()> {
        info!(path = ?self.path, "Removing existing src directory");
        tokio::fs::remove_dir_all(&self.path).await?;

        info!(path = ?self.path, "Creating new src directory");
        tokio::fs::create_dir(&self.path).await?;

        self.lib_rs.init().await?;
        Ok(())
    }

    pub fn lib_rs(&self) -> &LibRs {
        &self.lib_rs
    }

    #[allow(unused)]
    pub fn relative_path<P: AsRef<Path>>(&self, join: P) -> PathBuf {
        self.path.join(join)
    }
}

#[derive(Debug)]
pub(crate) struct LibRs {
    path: PathBuf,
}

impl LibRs {
    pub async fn init(&self) -> Result<()> {
        info!(path = ?self.path, "Creating new lib.rs file.");
        tokio::fs::OpenOptions::new()
            .create_new(true)
            .write(true)
            .open(&self.path)
            .await?
            .write("#![allow(non_snake_case)]\n".as_bytes())
            .await?;
        Ok(())
    }

    /// Opens the file for appending thereby creating it if non-existent.
    pub async fn append(&self) -> Result<tokio::io::BufWriter<tokio::fs::File>> {
        Ok(tokio::io::BufWriter::new(
            tokio::fs::OpenOptions::new()
                .create(true)
                .append(true)
                .open(&self.path)
                .await
                .map_err(|err| {
                    error!(?err, "Could not open lib.rs file to append modules.");
                    err
                })?,
        ))
    }
}

#[derive(Debug)]
pub(crate) struct CargoToml {
    file_path: PathBuf,
}

impl CargoToml {
    #[instrument(level = "info", skip_all)]
    pub async fn remove(&self) -> Result<()> {
        info!(cargo_toml = ?self.file_path, "Removing file.");
        tokio::fs::remove_file(&self.file_path)
            .await
            .map_err(Into::into)
    }

    #[instrument(level = "info", skip_all)]
    async fn create_file(&self) -> Result<tokio::fs::File> {
        info!(cargo_toml = ?self.file_path, "Creating file.");
        tokio::fs::OpenOptions::new()
            .create_new(true)
            .write(true)
            .open(&self.file_path)
            .await
            .map_err(|err| {
                error!(?err, "Could not create Cargo.toml.");
                err
            })
            .map_err(Into::into)
    }

    #[instrument(level = "info")]
    pub(crate) async fn init(&self) -> Result<()> {
        info!(cargo_toml = ?self.file_path, "Writing BASE_CARGO_TOML content.");
        self.create_file()
            .await?
            .write_all(BASE_CARGO_TOML.as_bytes())
            .await
            .map_err(Into::into)
    }

    #[instrument(level = "info", skip_all)]
    async fn append_file(&self) -> Result<tokio::io::BufWriter<tokio::fs::File>> {
        info!(cargo_toml = ?self.file_path, "Creating file.");
        Ok(tokio::io::BufWriter::new(
            tokio::fs::OpenOptions::new()
                .append(true)
                .open(&self.file_path)
                .await
                .map_err(|err| {
                    error!(?err, "Could not open Cargo.toml file to append data.");
                    err
                })?,
        ))
    }

    #[instrument(level = "info", skip(features))]
    pub(crate) async fn append_features(&self, features: Vec<Feature>) -> Result<()> {
        info!(
            num_features = features.len(),
            "Writing features to Cargo.toml."
        );
        let mut cargo_file = self.append_file().await?;
        for feature in features.iter() {
            cargo_file
                .write_all(format!("{} = []\n", &feature.name).as_bytes())
                .await?;
        }
        cargo_file.flush().await.map_err(|err| {
            error!(?err, "Could not flush Cargo.toml file after writing.");
            err
        })?;

        Ok(())
    }
}
